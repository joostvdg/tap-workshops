{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HOME","text":"<p>Welcome.</p> <p>For the Tanzu Solution Engineer workshops, visit the E2E Demo Portal.</p>"},{"location":"#links","title":"Links","text":""},{"location":"#examples","title":"Examples","text":"<ul> <li>Tanzu Labs US - Custom Cartographer Supply Chains</li> <li>TAP Application Accelerator samples</li> <li>VRabbi TAP GitOps</li> </ul>"},{"location":"#example-applications","title":"Example Applications","text":"<ul> <li>Where For Dinner - Main TAP demo application</li> <li>Spring Cloud Stream</li> <li>TAP - Open Telemetry For Applications demo</li> <li>Spring Cloud Demo</li> </ul>"},{"location":"#community-links","title":"Community Links","text":"<ul> <li>VRabbi - Whats New In 1.5</li> <li>VRabbi - TAP 1.5 GitOps</li> <li>VRabbi - Service Toolkit Dynamic Provisioning</li> </ul>"},{"location":"#other-links","title":"Other Links","text":"<ul> <li>Testcontainers with Tekton</li> <li>Tanzu Developer - Getting Started With Testcontainers</li> <li>CNCF Security TAG - Software Supply Chain Best Practices</li> <li>Miro Board with US based TAP Engagements</li> <li>Cartographer Lifecyle docs (useful for leveraging Tekton TaskRun)</li> <li>What Is Supply Chain Choreography, and Why Should You Care?</li> </ul>"},{"location":"apps/hello-world/","title":"TAP Workload Demo","text":"<p>Coming soon.</p>","tags":["tap","kubernetes","spring","java"]},{"location":"apps/spring-boot/","title":"Spring Boot Demo","text":"<p>Coming soon.</p>","tags":["tap","kubernetes","spring","java","spring-boot","mysql","crossplane"]},{"location":"apps/where-for-dinner/","title":"TAP Where For Dinner App","text":"","tags":["tap","kubernetes","spring","java","spring-boot","micoservice"]},{"location":"apps/where-for-dinner/#source","title":"Source","text":"<ul> <li>https://github.com/vmware-tanzu/application-accelerator-samples/blob/main/where-for-dinner/doc/TAPDeployment.md</li> </ul>","tags":["tap","kubernetes","spring","java","spring-boot","micoservice"]},{"location":"custom/supply-chain/","title":"Supply Chain Basic","text":"<p>Coming soon.</p>","tags":["tap","kubernetes","cartographer","tekton","supplychain"]},{"location":"install/basic/","title":"TAP Basic Install","text":"<p>Important</p> <p>The Goals and Outcomes is the work of Rick Farmer.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#goals-outcomes-operator","title":"Goals &amp; Outcomes Operator","text":"<ol> <li>I can do a basic install of TAP within a customer environment</li> <li>I have a basic understanding of the core features of TAP such that I can explain these to a customer</li> <li>I\u2019m able to demo TAP deployment via an OOTB accelerator and can explain the benefits of accelerator</li> </ol>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#checks","title":"Checks","text":"<ul> <li> Know the relevant parts of the docs</li> <li> Understand the prerequisites: TAP install</li> <li> Understand the prerequisites: Jump Host</li> <li> Can configure a TAP Full Profile config file</li> <li> Can discover how to configure TAP Packages</li> <li> Understand how to configure custom CA</li> <li> Can install TAP Full Profile</li> <li> I manually installed TAP</li> <li> I'm able to use an accelerator to generate a Web TAP Workload</li> <li> I'm able to manually setup a single developer namespace</li> <li> I applied a TAP Web Workload and register it within TAP GUI</li> <li> I'm able to do basic troubleshooting of a TAP Workload</li> <li> I'm able to do basic troubleshooting of a TAP Installation</li> <li> I've configured App Live View in TAP GUI for a TAP Web Workload</li> <li> I can update TAP values and reconcile changes on the cluster</li> <li> I understand TAP GUI Catalog System</li> <li> I know how to configure an integration to a private Git provider in TAP GUI</li> <li> I know how to configure access to private container registries in TAP Values</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#optional","title":"Optional","text":"<ul> <li> I'm able to install Learning Center and use the sample workshop.</li> <li> I understand the different Workload Types available in TAP</li> <li> I can configure a public Git provider for TAP GUI in TAP Values</li> <li> I can configure DNS for TAP Endpoints</li> <li> I have relocated TAP Images to my own container registry and understand the imgpkg utility.</li> <li> I understand Kapp Controller and Secret Gen Controller in the context of TAP</li> <li> I've able to configure and install the OOTB Testing and Scanning Supply Chain and verify a Workload</li> <li> I am able to configure a Scan Policy for a Source and Image Scan</li> <li> I am able to create a Tekton Task to execute Unit Tests within a Supply Chain for a Developer Namespace</li> <li> I know how to configure an Auth Provider for TAP GUI access</li> <li> I'm able to configure TAP GUI to read from Metadata Store.</li> <li> I know how to configure access to private repositories (SCM and Container) for TAP Workloads</li> <li> I am able to register API Documentation for a Workload in TAP GUI</li> <li> I am able to view and verify results for the Security Analysis within TAP GUI</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#steps","title":"Steps","text":"<ul> <li>Verify Prerequisites are met</li> <li>Install Cluster Essentials</li> <li>Choose TAP setup (profile, installation type)</li> <li>Review TAP packages configuration options<ul> <li>e.g., TAP values schema -&gt; map value to other package -&gt; other package values schema</li> </ul> </li> <li>Install TAP Profile</li> <li>Install Test Workload</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#verify-prerequisites-are-met","title":"Verify Prerequisites are met","text":"<p>The prerequisites1 we need:</p> <ul> <li>Credentials for Tanzu Net</li> <li>Credentials for local Container Image Registry</li> <li>Accept Tanzu Application Platform EULAs</li> <li>DNS Records for the clusters</li> <li>Suitable Kubernetes clusters</li> <li>Jump Host or other machine with the required tools in place</li> <li>Relocate TAP Images to local Container Image Registry</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#required-tools","title":"Required Tools","text":"<ul> <li>kubectl</li> <li>yq</li> <li>jq</li> <li>Tanzu CLI<ul> <li>with TAP plugins</li> </ul> </li> <li>curl</li> <li>...?</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#suitable-kubernetes-clusters","title":"Suitable Kubernetes clusters","text":"<p>TAP 1.5 supports Kubernetes 1.24, 1.25 and 1.262.</p> <p>Indicative cluster resource requirements of TAP per profile: (TODO: verify these numbers)</p> Profile Memory/Node Storage/Node vCPU Total Memory Total Iterate 8GB 150GB 12 16GB Build 16GB 150GB 12 12GB View 8GB 50GB 8 8GB Run 8GB 100GB 12 8GB Full 16GB 150BG 16 20GB <p>Warning</p> <p>These are requirements to run the TAP components. This does not include the applications or builds run in the cluster.</p> <p>For example, let's look at an application in a Run cluster. If your application requires 10vCPU and 40GB memory, you add that on top of the TAP requirements. Your Run cluser now needs a minimum of 22vCPU and 48GB of memory.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#tap-images-relocated","title":"TAP Images Relocated","text":"<p>TODO: provide information on what has been relocated and to where for the LAB environment 3</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-cluster-essentials","title":"Install Cluster Essentials","text":"<p>Cluster Essentials4 essentially (pun intended) boils down to two components:</p> <ul> <li>KAPP Controller5</li> <li>SecretGen Controller6</li> </ul> <p>Please install the Cluster Essentials4 according to the docs.</p> <p>Important</p> <p>While not explicitly mentioned, for each TAP minor version (e.g., 1.4, 1.5) there is an associated Cluster Essentials4.</p> <p>A minimum version of either controller is required, although there is no explicit version of either known at this point in time (April 2023).</p> <p>So unless there is a strong reason not too, use the Cluster Essentials referenced in the TAP docs.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#configure-certificate-authority","title":"Configure Certificate Authority","text":"<p>While TAP supports configuring a Certificate Authority (CA) to be trusted by the TAP machinery (or Workloads specifically11) this applies to when TAP is installed.</p> <p>To install TAP, we need to ensure that the KAPP Controller we install with the Cluster Essentials, also trusts our custom CA.</p> <p>When using a private registry, which we do, we need to create a Secret with a pre-defined name and structure. This kapp-controller-config12 Secret is expected to have the CA as Base64 encoded PEM in the field <code>caCerts</code>. Luckily, this is done with a single line via the kubectl create secret4 command.</p> <pre><code>kubectl create secret generic kapp-controller-config \\\n--namespace kapp-controller \\\n--from-file caCerts=ca.crt\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#choose-tap-setup-profile-installation-type","title":"Choose TAP setup (profile, installation type)","text":"<p>For almost every customer, the TAP installation covers multiple environments, multiple clusters, and various profiles.</p> <p>Some customers want a Run cluster per application, others assume multi-tenancy is oke.</p> <p>It is generally recommended to assume different environments with their own purpose. For example:</p> <ul> <li>Test: contains one or more clusters, regularly re-created, used for experimentation and learning. Only used by the Platform Team.</li> <li>Staging: multiple clusters and multiple profiles, used for testing specific features and upgrades. Used by the Platform Team, and a handful of \"beta testers\".</li> <li>Production: multiple clusters and multiple profiles, including an iterate cluster for learning for end-users.</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#full-profile-for-workshop","title":"Full Profile For Workshop","text":"<p>For the sake of brevity for this workshop, we'll stick to a single cluster with the Full profile.</p> <p>While this does not represent a typical installation, it let's you go through the steps of installing and using TAP. It also shows you all the components and let's you customize and interact with them, without having to go multiple times the same process.</p> <p>The Full profile contains all the components of TAP, which is what the name implies (not always true, but this time it is).</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-type","title":"Install Type","text":"<p>Next we choose how we want to install TAP.</p> <p>There are currently three options:</p> <ol> <li>Traditional manual KAPP package install, online</li> <li>Traditional manual KAPP package install, offline</li> <li>GitOps install, beta</li> </ol> <p>It is likely that the GitOps installation type will be the default in the future.</p> <p>For now the most common (and supported) installation is the Traditional Offline install.</p> <p>It is good to understand what steps need to be taken before automating them. So this is the type we'll use for this workshop.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#version","title":"Version","text":"<p>Ideally we want to use the latest (supported) version.</p> <p>Which at this time of writing is TAP 1.5.</p> <p>TAP 1.5 requires Kubernetes 1.24, so this is currently (April 2023) not supported on TGKs based customers, as they can only go to Kubernetes 1.23.</p> <p>Assuming that in due time vSphere 8 with TGKs does support 1.24 (the Supervisor cluster already does), TAP 1.5 is a relatively safe bet.</p> <p>TAP 1.6, not yet released, will require Kubernetes 1.25, which won't be supported anytime soon with TGKs or TGKm.</p> <p>So let's stick to TAP 1.5.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#conclusion","title":"Conclusion","text":"<p>Our TAP environment will be as follows:</p> <ul> <li>TAP 1.5</li> <li>single Kubernetes cluster of 1.24</li> <li>using the Full profile</li> <li>installed via the traditional KAPP package, assuming a internet restricted environment</li> </ul>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-package-repository","title":"Install Package Repository","text":"<p>Now that we know what version of TAP we want to install, and how we want to install it, we install the Package Repository.</p> <p>Assumptions: * All relevant TAP packages are relocated * We have read credentials to Image Registry containing the TAP apps * We have Kubernetes cluster   * Which runs a version that TAP supports (e.g., 1.24)   * The nodes trust the CA of Image Registry</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#create-required-secrets","title":"Create Required Secrets","text":"<p>The TAP Package Repository comes from either Tanzu Network or the Registry you relocated the TAP images to.</p> <p>In either case, you need a Registry read credential in the Namespace we install the Package Repository in.</p> <pre><code>TAP_INSTALL_NAMESPACE=tap-install\nTAP_INSTALL_REGISTRY_SECRET=tap-registry\nTAP_INSTALL_REGISTRY_HOSTNAME=\nTAP_INSTALL_REGISTRY_USERNAME=\nTAP_INSTALL_REGISTRY_PASSWORD=\n</code></pre> <p>First, create the Namespace:</p> <pre><code>kubectl create namespace ${TAP_INSTALL_NAMESPACE} || true\n</code></pre> <p>And then use the Tanzu CLI to create a credential via the SecretGen Controller:</p> <pre><code>tanzu secret registry add ${TAP_INSTALL_REGISTRY_SECRET} \\\n--username ${INSTALL_REGISTRY_USERNAME} \\\n--password ${INSTALL_REGISTRY_PASSWORD} \\\n--server ${INSTALL_REGISTRY_HOSTNAME} \\\n--namespace ${TAP_INSTALL_NAMESPACE} \\\n--export-to-all-namespaces \\\n--yes\n</code></pre> <p>Registry Write Secret</p> <p>TAP profiles <code>Iterate</code>, <code>Full</code>, and <code>Build</code>, also need a Registry write secret.</p> <p>This secret is used to write built images of the applications going throuhg the Supply Chains. Define the appropriate environment variables:</p> <pre><code>TAP_INSTALL_NAMESPACE=tap-install\nTAP_BUILD_REGISTRY_SECRET=registry-credentials\nTAP_BUILD_REGISTRY_HOSTNAME=\nTAP_BUILD_REGISTRY_USERNAME=\nTAP_BUILD_REGISTRY_PASSWORD=\n</code></pre> <p>And then we use the Tanzu CLI to create the secret:</p> <pre><code>tanzu secret registry add ${TAP_BUILD_REGISTRY_SECRET} \\\n--username ${TAP_BUILD_REGISTRY_USERNAME} \\\n--password ${TAP_BUILD_REGISTRY_PASSWORD} \\\n--server   ${TAP_BUILD_REGISTRY_HOSTNAME} \\\n--namespace ${TAP_INSTALL_NAMESPACE} \\\n--export-to-all-namespaces \\\n--yes\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#create-package-repository","title":"Create Package Repository","text":"<p>To make the values less abstract, let's look at an example.</p> <p>Assume we have a internal Harbor registry, with the hostname <code>harbor.example.com</code>. We create a project in this Harbor instance called <code>tap</code>, and relocated the TAP packages to this project as <code>tap-packages</code>.</p> <p>The complete URL will now be: <code>harbor.example.com/tap/tap-packages:1.5.0</code>.</p> <p>And our environment variables will be:</p> <ul> <li><code>INSTALL_REGISTRY_REPO=tap</code></li> <li><code>INSTALL_REGISTRY_HOSTNAME=harbor.example.com</code></li> <li><code>TAP_VERSION=1.5.0</code></li> </ul> <p>Set the environment variables to values appropriate for your environment.</p> <pre><code>TAP_INSTALL_NAMESPACE=tap-install\nTAP_VERSION=1.5.0\nINSTALL_REGISTRY_REPO=tap\nINSTALL_REGISTRY_HOSTNAME=\n</code></pre> <p>And use the Tanzu CLI to create the Package Repository for TAP in the TAP install Namespace (usually <code>tap-install</code>).</p> <pre><code>tanzu package repository add tanzu-tap-repository \\\n--url ${INSTALL_REGISTRY_HOSTNAME}/${INSTALL_REGISTRY_REPO}/tap-packages:${TAP_VERSION} \\\n--namespace ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>Run the command below to verify the Package Repository is reconciled successfully:</p> <pre><code>tanzu package repository list -n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>This should return something like this:</p> <pre><code>  NAME                      SOURCE                                                                            STATUS\n  tanzu-tap-repository      (imgpkg) harbor.services.h2o-2-9349.h2o.vmware.com/tap/tap-packages:1.5.0         Reconcile succeeded\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#configure-certificate-authority-bundle-for-crossplane","title":"Configure Certificate Authority Bundle For Crossplane","text":"<p>The use of external services via the Bitnami Services14 feature relies on Crossplane15.</p> <p>Unfortunately, in the <code>1.5.0</code> release of TAP, the Crossplane package does not pickup the <code>shared.ca_cert_data</code> property.</p> <p>This means we must configure Crossplane ourselves. Crossplane expects a ConfigMap with a ca-bundle property13, which we later configure when installing TAP Profile.</p> <p>First, verify the <code>crossplane-system</code> namespace exists:</p> <pre><code>kubectl create namespace crossplane-system || true\n</code></pre> <p>And then create the ConfigMap with the expected name and value.</p> <pre><code>kubectl -n crossplane-system create cm ca-bundle-config \\\n--from-file=ca-bundle=ca.crt\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#review-tap-packages-configuration-options","title":"Review TAP packages configuration options","text":"<p>Before we can install our TAP Profile as desired, we need to understand how to configure it.</p> <p>We can take a look at the available packages and specifically the TAP package itself to discover what we can configure.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#explore-packages","title":"Explore Packages","text":"<p>The first step, is to discover the packages available to us.</p> <pre><code>tanzu package available list --namespace ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>This is a large list, so we'll limit the expected output:</p> <pre><code>  NAME                                                 DISPLAY-NAME\n  accelerator.apps.tanzu.vmware.com                    Application Accelerator for VMware Tanzu\n  api-portal.tanzu.vmware.com                          API portal\n  apis.apps.tanzu.vmware.com                           API Auto Registration for VMware Tanzu\n  ...\n</code></pre> <p>To see what we can configure with TAP, we have to take a few steps:</p> <pre><code>tanzu package available get tap.tanzu.vmware.com --namespace ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>This returns the versions of the TAP main package available to us.</p> <p>You can also get a list of available packages and their version via <code>kubectl</code>:</p> <pre><code>kubectl get package -n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>Which results in something like this:</p> <pre><code>NAME                                                            PACKAGEMETADATA NAME                                  VERSION                         AGE\nantrea.tanzu.vmware.com.1.7.2+vmware.1-tkg.1-advanced           antrea.tanzu.vmware.com                               1.7.2+vmware.1-tkg.1-advanced   646h52m30s\ncapabilities.tanzu.vmware.com.0.28.1+vmware.1                   capabilities.tanzu.vmware.com                         0.28.1+vmware.1                 646h52m34s\nkube-vip-cloud-provider.tanzu.vmware.com.0.0.4+vmware.2-tkg.1   kube-vip-cloud-provider.tanzu.vmware.com              0.0.4+vmware.2-tkg.1            646h52m33s\n...\n</code></pre> <p>Eitherway, we now know the version of the TAP package available to us, <code>1.5.0</code>. We need this information if we want to see the possible values for the TAP package.</p> <p>We add the version to the package name (<code>&lt;packageName&gt;/&lt;packageVersion&gt;</code>), and then add the <code>--values-schema</code> flag.</p> <pre><code>tanzu package available get tap.tanzu.vmware.com/1.5.0 \\\n--namespace ${TAP_INSTALL_NAMESPACE} \\\n--values-schema\n</code></pre> <p>This results in a long list of possible values:</p> <pre><code>  KEY                                                  DEFAULT                 TYPE    DESCRIPTION\n  appliveview                                                                  object  App Live View configuration\n  contour.envoy.service.type                           LoadBalancer            string  Set to LoadBalancer by default; valid values are LoadBalancer, NodePort and\n                                                                                       ClusterIP(except for contour.infrastructure_provider=vsphere)\ncrossplane                                                                   object  Crossplane configuration\n  image_policy_webhook                                                         object  Image Policy Webhook configuration\n  learningcenter                                                               object  Learning Center configuration\n  ...\n</code></pre> <p>As you can probably tell, many of these values are not explained at this level.</p> <p>For example, the <code>TYPE</code> of <code>crossplane</code> is <code>object</code>. We will have to explore the values schema of the Crossplane package to discover what we can configure here if we need to.</p> <p>There is a lot of overlap between the packages, especially with configuration options such as a Domain name, secrets, or a custom CA.</p> <p>These are conventient configurable via the <code>shared</code> configuration key:</p> <pre><code>tanzu package available get tap.tanzu.vmware.com/1.5.0 \\\n--namespace ${TAP_INSTALL_NAMESPACE} \\\n--values-schema | grep shared.\n</code></pre> <p>This gives the following list:</p> <pre><code>  shared.image_registry.password                       \"\"                      string  Optional: Password for the image registry. Mutually exclusive with\n                                                                                       shared.image_registry.secret.name/namespace.\n  shared.image_registry.project_path                   \"\"                      string  Optional: Project path in the image registry server used for builder and\n  shared.image_registry.secret.name                    \"\"                      string  Optional: Secret name for the image registry credentials of\n                                                                                       shared.image_registry.username/password.\n  shared.image_registry.secret.namespace               \"\"                      string  Optional: Secret namespace for the image registry credentials. Mutually\n                                                                                       exclusive with shared.image_registry.username/password.\n  shared.image_registry.username                       \"\"                      string  Optional: Username for the image registry. Mutually exclusive with\n                                                                                       shared.image_registry.secret.name/namespace.\n  shared.ingress_domain                                \"\"                      string  Optional: Domain name to be used in service routes and hostnames for instances\n  shared.ingress_issuer                                tap-ingress-selfsigned  string  Optional: A cert-manager.io/v1/ClusterIssuer for issuing TLS certificates to TAP\n  shared.kubernetes_distribution                       \"\"                      string  Optional: Type of K8s infrastructure being used. Can be used in coordination\n  shared.kubernetes_version                            \"\"                      string  Optional: K8s version. Can be used independently or in coordination with\n  shared.activateAppLiveViewSecureAccessControl                                bool    Optional: Enable Secure Access Connection between App Live View Components\n  shared.ca_cert_data                                  \"\"                      string  Optional: PEM Encoded certificate data to trust TLS connections with a private\n</code></pre> <p>Let's dive into the Full profile next.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#full-profile-example-from-docs","title":"Full Profile Example From Docs","text":"<p>The documentation has an annotated Full profile configuration file7 example, you can expand the example below if you want to see it.</p> <p>Let's look at how we use YTT to template the Profile configuration.</p> Full Profile Example From Docs full-profile.yaml<pre><code>shared:\ningress_domain: \"INGRESS-DOMAIN\"\ningress_issuer: # Optional, can denote a cert-manager.io/v1/ClusterIssuer of your choice. Defaults to \"tap-ingress-selfsigned\".\nimage_registry:\nproject_path: \"SERVER-NAME/REPO-NAME\"\nsecret:\nname: \"KP-DEFAULT-REPO-SECRET\"\nnamespace: \"KP-DEFAULT-REPO-SECRET-NAMESPACE\"\nkubernetes_distribution: \"K8S-DISTRO\" # Only required if the distribution is OpenShift and must be used with the following kubernetes_version key.\nkubernetes_version: \"K8S-VERSION\" # Required regardless of distribution when Kubernetes version is 1.25 or later.\nca_cert_data: | # To be passed if using custom certificates.\n-----BEGIN CERTIFICATE-----\nMIIFXzCCA0egAwIBAgIJAJYm37SFocjlMA0GCSqGSIb3DQEBDQUAMEY...\n-----END CERTIFICATE-----\nceip_policy_disclosed: FALSE-OR-TRUE-VALUE # Installation fails if this is not set to true. Not a string.\n#The above keys are minimum numbers of entries needed in tap-values.yaml to get a functioning TAP Full profile installation.\n#Below are the keys which may have default values set, but can be overridden.\nprofile: full # Can take iterate, build, run, view.\nsupply_chain: basic # Can take testing, testing_scanning.\nootb_supply_chain_basic: # Based on supply_chain set above, can be changed to ootb_supply_chain_testing, ootb_supply_chain_testing_scanning.\nregistry:\nserver: \"SERVER-NAME\" # Takes the value from the shared section by default, but can be overridden by setting a different value.\nrepository: \"REPO-NAME\" # Takes the value from the shared section by default, but can be overridden by setting a different value.\ngitops:\nssh_secret: \"SSH-SECRET-KEY\" # Takes \"\" as value by default; but can be overridden by setting a different value.\ncontour:\nenvoy:\nservice:\ntype: LoadBalancer # This is set by default, but can be overridden by setting a different value.\nbuildservice:\n# Takes the value from the shared section by default, but can be overridden by setting a different value.\nkp_default_repository: \"KP-DEFAULT-REPO\"\nkp_default_repository_secret: # Takes the value from the shared section above by default, but can be overridden by setting a different value.\nname: \"KP-DEFAULT-REPO-SECRET\"\nnamespace: \"KP-DEFAULT-REPO-SECRET-NAMESPACE\"\ntap_gui:\nservice_type: ClusterIP # If the shared.ingress_domain is set as earlier, this must be set to ClusterIP.\nmetadataStoreAutoconfiguration: true # Create a service account, the Kubernetes control plane token and the requisite app_config block to enable communications between Tanzu Application Platform GUI and SCST - Store.\napp_config:\ncatalog:\nlocations:\n- type: url\ntarget: https://GIT-CATALOG-URL/catalog-info.yaml\nmetadata_store:\nns_for_export_app_cert: \"MY-DEV-NAMESPACE\"\napp_service_type: ClusterIP # Defaults to LoadBalancer. If shared.ingress_domain is set earlier, this must be set to ClusterIP.\nscanning:\nmetadataStore:\nurl: \"\" # Configuration is moved, so set this string to empty.\ngrype:\nnamespace: \"MY-DEV-NAMESPACE\"\ntargetImagePullSecret: \"TARGET-REGISTRY-CREDENTIALS-SECRET\"\n# In a single cluster, the connection between the scanning pod and the metadata store happens inside the cluster and does not pass through ingress. This is automatically configured, you do not need to provide an ingress connection to the store.\npolicy:\ntuf_enabled: false # By default, TUF initialization and keyless verification are deactivated.\ntap_telemetry:\ncustomer_entitlement_account_number: \"CUSTOMER-ENTITLEMENT-ACCOUNT-NUMBER\" # (Optional) Identify data for creating the Tanzu Application Platform usage reports.\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#full-profile-template","title":"Full Profile Template","text":"<p>Usually you will have more than one environment and possibly more than one of the same profile in the same environment. So you end up installing the same Profile more than once.</p> <p>It is recommended to use some kind of templating.</p> <p>In the world of Tanzu (and TAP), it makes sense to use YTT.</p> <p>TODO: review this by doing all the commands/use the template</p> full-profile.ytt.yaml<pre><code>#@ load(\"@ytt:data\", \"data\")\n#@ dv = data.values\n#@ kpRegistry = \"{}/{}\".format(dv.buildRegistry, dv.tbsRepo)\n---\nprofile: full\nshared:\ningress_domain: #@ dv.domainName\nca_cert_data: #@ dv.caCert\nimage_registry:\nproject_path: #@ kpRegistry\nsecret:\nname: #@ dv.buildRegistrySecret\nnamespace: tap-install\nbuildservice:\npull_from_kp_default_repo: true\nexclude_dependencies: true\nsupply_chain: basic\nootb_supply_chain_basic:\nregistry:\nserver: #@ dv.buildRegistry\nrepository: #@ dv.buildRepo\nappliveview_connector:\nbackend:\nsslDeactivated: true\ningressEnabled: true\nhost: #@ \"appliveview.\"+dv.domainName\nappliveview:\ningressEnabled: true\nserver:\ntls:\nenabled: false\ntap_gui:\nservice_type: ClusterIP\napp_config:\nauth:\nallowGuestAccess: true\ncustomize:\ncustom_name: 'Portal McPortalFace'\norganization:\nname: 'Org McOrg Face'\ncatalog:\nlocations:\n- type: url\ntarget: https://github.com/joostvdg/tap-catalog/blob/main/catalog-info.yaml\n- type: url\ntarget: https://github.com/joostvdg/tap-hello-world/blob/main/catalog/catalog-info.yaml\ncrossplane:\nregistryCaBundleConfig:\nname: ca-bundle-config\nkey: ca-bundle\ncontour:\nenvoy:\nservice:\ntype: LoadBalancer\nceip_policy_disclosed: true\nexcluded_packages:\n- scanning.apps.tanzu.vmware.com\n- grype.scanning.apps.tanzu.vmware.co\n- policy.apps.tanzu.vmware.com\n</code></pre> <p>Template Explained</p> <p><code>shared</code>: values that are to be shared across any package that has the same configuration option.    It is here we configure Install Registry credentials and custom CA.</p> <p><code>buildservice</code>: if your environment has no or restricted access to the internet, you need to manage the depencies yourself.   It can re-use the repository from the shared configuration. Here we do that, and tell it to exclude the depencies as we install them ourselves.</p> <p><code>supply_chain</code>: TAP can install one Cartographer Supply Chain fully*. You specify the Supply Chain by name,   and then configure the Supply Chain by its own name**, in our case <code>basic</code> and <code>ootb_supply_chain_basic</code>.    Where we override the default Registry and Repository; this is where our built images are pushed.</p> <p><code>appliveview</code>: the App Live View component let's use view registered application's resources existing across TAP cluster in the TAP GUI.   Note, this is a TAP GUI component and that is where you will find it.</p> <p><code>tap_gui</code>: the TAP GUI is the way to discover APIs, applications, accelerators and the like. It is Backstage with a few VMware Tanzu plugins included.   It has a lot of configuration options, most of which can be ignored for an initial installation.    To use TAP GUI, you have to specify an authorization provider. In the event you do not have one (ready), you set app_config.auth.allowGuestAccess to true.</p> <p><code>crossplane</code>: Crossplane is a new package for TAP 1.5, and unfortunately does not (yet) pick up the Shared CA configuration. So we have to configure this ourselves.   TAP provides external services for use with the Service Binding Specification. By default it includes Crossplane packages for several Bitnami Helm Charts (packed as Bitnami Services).</p> <p><code>ceip_policy_disclosed</code>: if you accept the policy or not. If you set this to false, you cannot install TAP</p> <p><code>excluded_packages</code>: the packages we exclude are from the Test &amp; Scanning Supply Chain. They require some configuration, especially if you are in a restricted internet access environment.   Because we are using the Basic Supply Chain, these packages are not required and we can exclude them.</p> <ul> <li>= the Test and Test &amp; Scanning Supply Chains do miss a Tekton task, but are complete beyond that</li> </ul> <p>** = each Supply Chain is its own Carvel Package part of the TAP Packages Repository</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#tanzu-build-service","title":"Tanzu Build Service","text":"<p>TAP includes a version of Tanzu Build Service (TBS). One of the things TBS needs, is a bunch of container images for the various Build Packs and the various versions of tech stacks they support.</p> <p>A full set of depencies is ~12 GB, and TBS starts synchronizing these to the nodes once it is up and running. There are two complications with this, one, thats a lot of data to synchronize from the outside, and two, you might not be able to reach the outside.</p> <p>So what we do instad, is to relocate the TBS depencies8, in the same way as we do with the TAP packages.</p> <p>We configured this in the TAP Profile already, by specifying the following:</p> <pre><code>buildservice:\nexclude_dependencies: true\n</code></pre> <p>We cannot install the TAP TBS Dependencies (a TAP specific bundle of TBS) until we install TAP. The TAP TBS Dependencies package depends on CRDs that are installed by TAP. So we will continue this later.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-tap-profile","title":"Install TAP Profile","text":"<p>At this point, we have the following:</p> <ul> <li>TAP Packages available in a local Image Registry</li> <li>TAP TBS Dependencies available in a local Image Registry</li> <li>A Namespace to install TAP into (the concention is <code>tap-install</code>)</li> <li>Read access secret to the local Image Registry to retrieve the TAP packages</li> <li>Write access secret to the local Image Registry to write application build images to</li> <li>Profile Template for our Profile of choice (<code>Full</code>)</li> </ul> <p>We now take the following steps:</p> <ol> <li>Generate a Profile config file from the YTT Template</li> <li>Install the TAP package</li> <li>Install the TBS Dependencies Package Repository</li> <li>Install the TBS Dependencies Package</li> </ol>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#generate-profile-config-file","title":"Generate Profile Config FIle","text":"<p>First, we set the required variables:</p> <p>Warning</p> <p>You should have received the address of the Build Registry and the Domain specific to your cluster!</p> <pre><code>export TAP_BUILD_REGISTRY_SECRET=registry-credentials\nexport BUILD_REGISTRY_REPO=tap-apps\nexport TBS_REPO=buildservice/tbs-full-deps\nexport CA_CERT=$(cat ssl/ca.pem)\nexport BUILD_REGISTRY=\nexport DOMAIN_NAME=\n</code></pre> <p>And then we run YTT to generate our Profile configuration file.</p> <pre><code>ytt -f full-profile.ytt.yaml \\\n-v buildRegistry=\"$BUILD_REGISTRY\" \\\n-v buildRegistrySecret=\"$BUILD_REGISTRY_SECRET\" \\\n-v buildRepo=\"$BUILD_REGISTRY_REPO\" \\\n-v tbsRepo=\"$TBS_REPO\" \\\n-v domainName=\"$DOMAIN_NAME\" \\\n-v caCert=\"${CA_CERT}\" \\\n&gt; \"tap-values-full.yml\"\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-tap-package","title":"Install TAP Package","text":"<p>We are now ready to install TAP.</p> <p>In case you don't remember or your environment variables are no longer set, set them to the appropriate values:</p> <pre><code>export TAP_INSTALL_NAMESPACE=tap-install\nexport TAP_VERSION=1.5.0\n</code></pre> <p>We can then install TAP9 via the Tanzu CLI.</p> <pre><code>tanzu package install tap \\\n-p tap.tanzu.vmware.com \\\n-v $TAP_VERSION \\\n--values-file tap-values-full.yml \\\n-n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>You can get an overview of the Packages that are installed via the Tanzu CLI:</p> <pre><code>tanzu package installed list -n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>Or via <code>kubectl</code>:</p> <pre><code>kubectl get app -n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>If there is an issue, you can debug the package installs via <code>kubectl</code> commands:</p> <pre><code>kubectl describe app -n ${TAP_INSTALL_NAMESPACE} tap\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#determine-tbs-version","title":"Determine TBS Version","text":"<p>Now that we have the TAP package installed, we can install the TBS dependencies.</p> <p>First, we need to verify which version of TBS TAP shipped8.</p> <pre><code>tanzu package available list buildservice.tanzu.vmware.com \\\n--namespace ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>Which for TAP <code>1.5.0</code> gives the following result:</p> <pre><code>  NAME                           VERSION  RELEASED-AT\n  buildservice.tanzu.vmware.com  1.10.8   -\n</code></pre> <p>We then set the environment variable, so we can re-use it:</p> <pre><code>export TBS_VERSION=1.10.8\n</code></pre> <p>Note</p> <p>Your environment should already have the TBS Dependencies relocated for you.</p> <p>If you want to know how to do so, you can find it documented here8</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-tbs-depencies-package-repository","title":"Install TBS Depencies Package Repository","text":"<p>In case you have not yet, set the environment variables.</p> <pre><code>export TBS_REPO=buildservice/tbs-full-deps\n</code></pre> <p>And we then we can install the TBS Dependencies Package Repository:</p> <pre><code>tanzu package repository add tbs-full-deps-repository \\\n--url ${INSTALL_REGISTRY_HOSTNAME}/${TBS_REPO}:VERSION \\\n--namespace ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>We can verify the status via the Tanzu CLI:</p> <pre><code>tanzu package repository list -n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>Which should now yield this:</p> <pre><code>  NAME                      SOURCE                                                                            STATUS\n  tanzu-tap-repository      (imgpkg) harbor.services.h2o-2-9349.h2o.vmware.com/tap/tap-packages:1.5.0         Reconcile succeeded\n  tbs-full-deps-repository  (imgpkg)                                                                          Reconcile succeeded\n                            harbor.services.h2o-2-9349.h2o.vmware.com/buildservice/tbs-full-deps:1.10.8\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-tbs-full-dependencies-package","title":"Install TBS Full Dependencies Package","text":"<p>We can now install the TBS Full Dependencies package8:</p> <pre><code>tanzu package install full-tbs-deps \\\n-p full-tbs-deps.tanzu.vmware.com \\\n-v ${TBS_VERSION} \\\n-n ${TAP_INSTALL_NAMESPACE}\n</code></pre> <p>And then verify the package is installed and reconciled correctly:</p> <pre><code>tanzu package installed get full-tbs-deps -n $TAP_INSTALL_NAMESPACE\n</code></pre> <p>Which should return something like this:</p> <pre><code>NAMESPACE:          tap-install\nNAME:               full-tbs-deps\nPACKAGE-NAME:       full-tbs-deps.tanzu.vmware.com\nPACKAGE-VERSION:    1.10.8\nSTATUS:             Reconcile succeeded\nCONDITIONS:         - type: ReconcileSucceeded\n  status: \"True\"\nreason: \"\"\nmessage: \"\"\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#install-test-application","title":"Install Test Application","text":"<ul> <li>explain workloads</li> <li>CLI</li> <li>namespace &amp; namespace provisioner</li> <li>?</li> </ul> <p>One of the goals of TAP is to be flexible, to support the various ways people build and run applications.</p> <p>Cartographer's Supply Chains let you define any workflow you want for any kind of resource you can express in Kubernetes.</p> <p>While that is interesting, starting with the basics, we focus on the <code>batteries included</code> part. Which gives you three main workflows:</p> <ul> <li>build an application</li> <li>run an application</li> <li>both build &amp; run an application</li> </ul> <p>Each of the three Out-Of-The-Box (OOTB) Supply Chains comes with two <code>ClusterSupplyChain</code> CRs.</p> <ul> <li><code>x-image-to-url</code></li> <li><code>source-x-to-url</code></li> </ul> <p>The Source to Image journey is defined by the <code>Workload</code> CR. The Image to URL journey is defined by the <code>Deliverable</code> CR.</p> <p>When you start at the Source, the OOTB Supply Chains generate the <code>Deliverable</code> CR for you.</p> <p>To test if our TAP machinery works as intended, we'll stick to creating a <code>Workload</code> that uses the <code>source-to-url</code> Supply Chain.</p> <p>In order to the tools used by the Supply Chain to do their work, they need the appropriate Secrets and RBAC permissions. So we start with setting up a Developer Namespace.</p>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#set-up-developer-namespace","title":"Set Up Developer Namespace","text":"<p>Starting with TAP 1.5, it includes a package called the Namespace Provisioner10.</p> <p>This let's us configure Developer Namespaces by adding Label.</p> <pre><code>export TAP_DEVELOPER_NAMESPACE=dev\n</code></pre> Via kubectlVia Manifest <pre><code>kubectl create namespace ${TAP_DEVELOPER_NAMESPACE}\nkubectl label namespace ${TAP_DEVELOPER_NAMESPACE} \\\napps.tanzu.vmware.com/tap-ns=\"\"\n</code></pre> <pre><code>cat &lt;&lt;EOF &gt; tap-dev-namespace.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  labels:\n    apps.tanzu.vmware.com/tap-ns: \"\"\n    kubernetes.io/metadata.name: ${TAP_DEVELOPER_NAMESPACE}\n  name: ${TAP_DEVELOPER_NAMESPACE}\nEOF\n</code></pre> <pre><code>kubectl apply -f tap-dev-namespace.yaml\n</code></pre> <p>If we wait a few moments, we can then see the Namespace contains Secrets and RoleBindings:</p> <pre><code>kubectl get secret,rolebinding -n $TAP_DEVELOPER_NAMESPACE\n</code></pre> <p>Which shows something like this:</p> <pre><code>NAME                            TYPE                             DATA   AGE\nsecret/registries-credentials   kubernetes.io/dockerconfigjson   1      25d\n\nNAME                                                            ROLE                   AGE\nrolebinding.rbac.authorization.k8s.io/default-permit-workload   ClusterRole/workload   25d\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#create-workload","title":"Create Workload","text":"<p>Now that we have a Namespace to work in, we can define a Workload.</p> <p>We can then either use the CLI or the <code>Workload</code> CR to create our test workload.</p> Tanzu CLIKubernetes Manifest <pre><code>tanzu apps workload create smoke-app \\\n--git-repo https://github.com/sample-accelerators/tanzu-java-web-app.git \\\n--git-branch main \\\n--type web \\\n--label app.kubernetes.io/part-of=smoke-app \\\n--annotation autoscaling.knative.dev/minScale=1 \\\n--yes \\\n-n \"$TAP_DEVELOPER_NAMESPACE\"\n</code></pre> <pre><code>echo \"apiVersion: carto.run/v1alpha1\nkind: Workload\nmetadata:\n  labels:\n    app.kubernetes.io/part-of: smoke-app\n    apps.tanzu.vmware.com/workload-type: web\n  name: smoke-app\n  namespace: ${TAP_DEVELOPER_NAMESPACE}\nspec:\n  params:\n  - name: annotations\n    value:\n      autoscaling.knative.dev/minScale: \\\"1\\\"\n  source:\n    git:\n      ref:\n        branch: main\n      url: https://github.com/sample-accelerators/tanzu-java-web-app.git\n\" &gt; workload.yml\n</code></pre> <pre><code>kubectl apply -f workload.yml\n</code></pre> <p>Use <code>kubectl wait</code> to wait for the app to be ready.</p> <pre><code>kubectl wait --for=condition=Ready Workload smoke-app --timeout=10m -n \"$TAP_DEVELOPER_NAMESPACE\"\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#verify-workload","title":"Verify Workload","text":"<p>To see the logs:</p> <pre><code>tanzu apps workload tail smoke-app\n</code></pre> <p>To get the status:</p> <pre><code>tanzu apps workload get smoke-app\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#delete-workload","title":"Delete Workload","text":"<p>And then we can delete our test workload if want to.</p> <pre><code>tanzu apps workload delete smoke-app -y -n \"$TAP_DEVELOPER_NAMESPACE\"\n</code></pre>","tags":["tap","kubernetes","install"]},{"location":"install/basic/#links","title":"Links","text":"<ol> <li> <p>TAP 1.5 - Prerequisites \u21a9</p> </li> <li> <p>TAP 1.5 - Supported Kubernetes versions \u21a9</p> </li> <li> <p>TAP 1.5 - Relocate images to a registry \u21a9</p> </li> <li> <p>TAP 1.5 - Cluster Essentials \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>KAPP Controller - Overview \u21a9</p> </li> <li> <p>SecretGen Controller - GitHub page \u21a9</p> </li> <li> <p>TAP 1.5 - Full profile example \u21a9</p> </li> <li> <p>TAP 1.5 - Handle TBS Depencies \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>TAP 1.5 - Install TAP Package \u21a9</p> </li> <li> <p>TAP 1.5 - Namespace Provisioner \u21a9</p> </li> <li> <p>TAP 1.5 - Trust CA for Workload specifically \u21a9</p> </li> <li> <p>KAPP Controller - Configure Controller to Trust custom CA \u21a9</p> </li> <li> <p>Crossplane - Configure Self-signed CA Certs support \u21a9</p> </li> <li> <p>TAP 1.5 - Bitnami Services \u21a9</p> </li> <li> <p>Crossplane - The Cloud Native Control Plane Framework \u21a9</p> </li> </ol>","tags":["tap","kubernetes","install"]},{"location":"install/gitops/","title":"TAP GitOps Install","text":"<p>Coming soon.</p>","tags":["tap","kubernetes","install","GitOps"]},{"location":"install/gitops/#links","title":"Links","text":"<ul> <li>Official Docs</li> <li>VRabbi Blog</li> <li>Mozilla SOPS</li> </ul>","tags":["tap","kubernetes","install","GitOps"]}]}